{% extends 'base.html' %} {% block header %}
<h2>{% block title %} Forward Difference {% endblock title %}</h2>
{% endblock header %} {% block content %}
<main class="bg-gray-100 py-8" style="background-image: url('https://www.transparenttextures.com/patterns/inflicted.png');">
    <div class="container mx-auto flex flex-col md:flex-row justify-center mb-36">
        {% include("/pages/numerical calculus/forward difference/_sidebar.html") %}
    </div>
    <div class="w-full md:w-3/4 p-4">
        <div class="bg-white rounded-lg shadow-lg p-8">
          <div class="container mx-auto">
            <div class="mb-6">
                <h3 class="text-2xl font-semibold">BACKGROUND</h3>
              </div>
              <div>
                <p class="text-xl font-semibold text-red-600 mb-4">
                  Forward Techniques
                </p>
                <p class="mb-4">
                  The first technique, based on the Intermediate Value Theorem, is
                  called the Bisection, or Binary-search, method. Suppose f is a
                  continuous function defined on the interval [a,b], with \(f(a)\) and
                  \(f(b)\) of opposite sign. The Intermediate Value Theorem implies that
                  a number p exists in \((a,b)\) with \(f(p) = 0\). Although the
                  procedure will work when there is more than one root in the interval
                  \((a,b)\), we assume for simplicity that
                   the root in this interval is
                  unique. The method calls for a repeated halving (or bisecting) of
                  subintervals of \([a,b]\) and, at each step, locating the half
                  containing p.
                </p>
                <p class="mb-4">
                  To begin, set \(a_1 = a \) and \(b_1 = b\), and let \(p_1\) be the
                  midpoint of [a,b]; that is \[p_1 = a_1 + \frac{b_1 - a_1}{2} =
                  \frac{a_1 + b_1}{2}\].
                </p>
                <ul class="list-disc pl-6 space-y-2">
                  <li>If \(f(p_1) = 0\), then \(p=p_1\), and we are done.</li>
                  <li>
                    If \(f(p_1) \neq 0\), then \(f(p_1)\) has the same sign as either
                    \(f(a_1)\) or \( f(b_1)\).
                  </li>
                  <li>
                    If \(f(p_1)\) and \(f(a_1)\) have the same sign, \(p \in(p_1,b_1)\).
                    Set \(a_2 = p_1\) and \(b_2 = b_1\).
                  </li>
                  <li>
                    If \(f(p_1)\) and \(f(a_1)\) have opposite signs, \(p
                    \in(a_1,b_1)\). Set \(a_2 = p_1\) and \(b_2 = p_1\).
                  </li>
                </ul><br>
                <h2 class='text-center font-bold underline'>GRAPH FOR BISECTION</h2>
                <img
              src="{{url_for('static', filename='forwardpic.png')}}"
              alt="bis-graph" class='mx-auto'
            />
            <ul>
              <li><a href='https://books.google.com/books/about/Numerical_Analysis.html?id=zXnSxY9G2JgC' class='text-red-500 font-bold underline'>References: Numerical Analysis, 9th by Richard L. Burden and J.Douglas Faires</a></li>
            </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
  </div>
</main>
{% endblock content %}
